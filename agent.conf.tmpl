# Supported Labels:
#
# fluentd.pattern = <regex> If not set, all logs will be ignored
# fluentd.private = true|false (default false) don't send to global label
# fluentd.ignore = true|false If true, messages will be dropped (evaluated on a per-message basis)
# fluentd.targets = <stack/service> (default own stack/service)
#  => this can be overridden on a per-message basis by using an expression pattern that overrides fluentd.targets
#  => any stack/service in rancher is an available target (though they might not do anything with the messages)

# Tail all docker container json logs
<source>
  @type tail
  path /var/lib/docker/containers/*/*-json.log
  pos_file /home/fluent/fluentd-docker.pos
  tag docker.*
  format json
  time_key time
  time_format %Y-%m-%dT%H:%M:%S.%NZ
</source>

# Attach container labels & other info
# This drops messages from containers
# without fluentd.pattern label
<filter docker.var.lib.docker.containers.**>
  @type docker
  container_id "${tag_parts[5]}"
  targets_label "docker.container.labels.io.rancher.stack_service.name"
</filter>

# Rewrite tag to docker.<container_name> for readability
<match docker.var.lib.docker.containers.**>
  @type rewrite_tag
  rewriterule1 docker.container.name (.+) docker.$1
</match>

# Concat multiline messages
# (any line that starts with whitespace
#  will be joined to the previous message)
#
# TODO: allow specification of multiline
#       pattern in fluentd.multiline label

<filter docker.*>
  @type concat
  @log_level warn
  key log
  use_first_timestamp true
  stream_identity_key docker.container.id
  multiline_start_regexp /^\S+/
  timeout_label @DEFAULT
  separator ""
  flush_interval 2s
</filter>

# Relabel so that concat successes and
# timeouts end up in the same pipeline
<match docker.*>
  @type relabel
  @label @DEFAULT
</match>

<label @DEFAULT>
  # extract fields from fluentd.pattern
  <filter docker.*>
    @type expat
  </filter>

  <filter docker.*>
    @type record_transformer
    renew_time_key actual_unix_timestamp
  </filter>

  <filter docker.*>
    @type kibana
    {{- with host }}
    hostname {{ .Name }}
    group {{ .Labels.GetValue "rancher-group" }}
    provider aws
    region {{ .Labels.GetValue "region" }}
    az {{ .Labels.GetValue "zone" }}
    machine {{ .Labels.GetValue "instance-type" }}
    {{- end }}
  </filter>

  # Fan out to specified target labels
  <match docker.*>
    @type fanout
    targets_key docker.container.labels.fluentd.targets
  </match>
</label>

# Start service-defined pipelines
{{- range services }}
{{- $stack := .Stack }}{{ $service := .Name }}
{{ if not .Parent }}
<label @{{ $stack }}/{{ $service }}>
{{- else }}{{- with .Parent }}
<label @{{ $stack }}/{{ .Name }}/{{ $service }}>
{{- end }}{{- end }}
{{- if .Metadata.GetValue "fluentd" }}{{ $fluentd := .Metadata.GetValue "fluentd" }}
{{- if $fluentd.service }}
{{ $fluentd.service }}
{{- else }}
  <match **>
    @type null
  </match>{{ end }}{{- else }}
  <match **>
    @type null
  </match>
{{- end }}
</label>
{{- end }}

# End service-defined pipelines

<label @GLOBAL>
{{- with service }}
{{- with .Parent }}
{{- $dest := .Labels.GetValue "fluentd.forward" }}
{{- with service $dest }}
<match **>
  @type forward
  send_timeout 60s
  recover_wait 10s
  hard_timeout 60s
  {{- range .Containers }}
  <server>
    name {{ .Name }}
    host {{ .Address }}
    port 24224
    weight 60
  </server>
  {{- end }}
</match>
{{- end }}
{{- end }}
{{- end }}
</label>
